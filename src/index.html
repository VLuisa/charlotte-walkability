<!DOCTYPE html>
<html>
<head>
    <meta charset='utf-8' />
    <title>Charlotte Walkability</title>
    <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />
    <script src='https://api.tiles.mapbox.com/mapbox-gl-js/v2.11.0/mapbox-gl.js'></script>
    <link href='https://api.tiles.mapbox.com/mapbox-gl-js/v2.11.0/mapbox-gl.css' rel='stylesheet' />
    <script src="https://unpkg.com/intersection-observer@0.12.0/intersection-observer.js"></script>
    <script src="https://unpkg.com/scrollama"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans:ital,wght@0,100..900;1,100..900&family=Sansita:ital,wght@0,400;0,700;0,800;0,900;1,400;1,700;1,800;1,900&display=swap" rel="stylesheet">
    <style>
        body {
            margin:0;
            padding:0;
            font-family: 'Noto Sans', sans-serif;
            background-color: #7841fd;
        }
        a, a:hover, a:visited {
            color: pink;
        }
        #map {
            top:0;
            height: 100%;
            left: 40vw;
            width:60vw;
            position: fixed;
            z-index: 0;
        }
        #mapInset {
            bottom:50px;
            right:30px;
            height: 180px;
            width:250px;
            max-width:100%;
            position: fixed;
            z-index: 1;
            opacity: 1;
            transition: opacity 0.5s ease-in-out;
            pointer-events: none;
        }
        #mapInset .mapboxgl-ctrl-bottom-left{
            display: none;
        }
        @media (max-width: 500px) {
            #mapInset {
                display: none;
            }
        }
        #header {
            margin: auto;
            width: 100%;
            height: 100%;
            position: relative;
            z-index: 20;
            display: flex;
            flex-flow: column nowrap;
            background-color: #7841fd;
        }
        #methods {
            margin: auto;
            width: 100%;
            height: 100%;
            position: relative;
            z-index: 20;
            display: flex;
            flex-flow: column nowrap;
            background-color: #472796;
            padding-bottom: 20vh;
        }

        #header h1, #header h2, #header p {
            padding: 2vh 2vw;
            text-align: left;
            max-width: 600px;
        }
        #footer {
            width: 100%;
            min-height: 5vh;
            padding-top: 2vh;
            padding-bottom: 2vh;
            text-align: center;
            line-height: 25px;
            font-size: 13px;
            position: relative;
            z-index: 5;
        }
        #features {
            padding-top: 10vh;
            padding-bottom: 10vh;
        }
        .hidden {
            visibility: hidden;
        }
        .centered {
            width: 50vw;
            margin: 0 auto;
        }
        .lefty {
            width: 33vw;
            margin-left: 5vw;
        }
        .righty {
            width: 33vw;
            margin-left: 62vw;
        }
        .fully {
            width: 100%;
            margin: auto;
        }
        .light {
            color: #444;
            background-color: #fafafa;
        }
        .dark {
            color: #fafafa;
            background-color: #7841fd;
        }
        .step {
            padding-bottom: 50vh;
            /* margin-bottom: 10vh; */
            opacity: 0.25;
        }
        .step.active {
            opacity: 0.9;
        }

        .step div {
            padding:  25px 50px;
            line-height: 25px;
            font-size: 22px;
        }

        .step img {
            width: 100%;
        }

        @media (max-width: 750px) {
            .centered, .lefty, .righty, .fully {
                width: 90vw;
                margin: 0 auto;
            }
        }

        /* Fix issue on mobile browser where scroll breaks  */
        .mapboxgl-canvas-container.mapboxgl-touch-zoom-rotate.mapboxgl-touch-drag-pan,
        .mapboxgl-canvas-container.mapboxgl-touch-zoom-rotate.mapboxgl-touch-drag-pan .mapboxgl-canvas {
            touch-action: unset;
        }
        #pink {
            color:#e68ef1;
        }

        #green {
            color: #47cce6;
        }

        h2 {
            font-family: 'Sansita', sans-serif;
            color: black;
            font-size: 2.5em;
            font-weight: 800;
            margin-top: 10vh;
        }

        #content {
            max-width: 50vw;
            min-width: 500px;
            justify-self: center;
            align-self: center;
        }

        #content p {
            font-size: 1.2em;
            color: white;
        }

        h4, h3, h5 {
            font-family: 'Sansita';
            font-weight: 800;
        }

        h3 {
            font-size: 12em;
            margin-top: -80px;
            margin-bottom: 20px;
        }

        h4 {
            margin-bottom: 0;
            font-size: 3.8em;
            margin-left: -150px;
        }

        #splash-header h2 {
            margin-top: 0;
            margin-bottom: 0;
            text-align: center;
        }

        #splash-header {
            display: flex;
            flex-flow: column nowrap;
            justify-content: center;
            align-items: center;
        }
        
        #methods h2 {
            color: white;
        }

        #methods p {
            font-size: 1em;
        }
        </style>
</head>
<body>
    <div id="header" class="dark">
        <div id="content">
            <div id="splash-header">
                <h4>I'd rather</h4>
                <h3>walk</h3>
                <h2>Exploring walkable areas in Charlotte, NC based on what matters to me</h2>
                <p>By Luisa Vasquez</p>
            </div>
            <p>I moved to Charlotte less than a year ago. And one of the things I still cannot get used to is that I have to drive everywhere.</p>
            <p>I used to live in Cambridge Massachusetts; a suburb across the river from Boston filled with cobblestone streets, ivy-covered brick buildings, and most memorably to me — easily accessible amenities that were all within walking distance.</p>
            <h2>A picture of a perfect weekend</h2>
            <p>To me a great weekend includes getting some books at the library, curling up to read them on a picnic blanket, and grabbing coffee at a cute coffee shop with some friends.</p>
            <p>When I lived in Cambridge, all of these things were simple to do and easy to walk to while listening to some tunes.</p>
            <h2>Walkability vs. Car culture</h2>
            <p>While chatting with other Charlotte transplants who came from various cities I noticed that everyone had a different definition of what makes an area “walkable”, based on what matters to them.</p>
            <p>Some come from cities with a big car culture and do not care about walkability when choosing where to live — they are content to drive everywhere.</p>
            <p>Walkability is important to me, and until now I have always lived in walkable neighborhoods.</p>    
            <p>I have joked that I would deem an area walkable if I could walk to the library and a cute coffee shop in 20 minutes.</p>    

            <h2>Where could I live in Charlotte?</h2>
            <p>I had a hunch that my low-estimation of Charlotte's walkability was colored by the exact area I live in, and likely doesn't reflect the experience of living everywhere in the city limits.</p>
            <p>So I decided to create a personal “walkability index” based on my preferences, to determine whether there's anywhere in Charlotte that would meet my walkability criteria.</p>
        </div>    
    </div>
<div id="map"></div>
<div id="mapInset"></div>
<div id="story"></div>
<div id="header">
    <div id="content">
        <h2>Walking in Charlotte</h2>
        <p>My walkability criteria is personal to me. There are other aspects to walkability that urban planners measure that I didn't account for - such as taking into consideration public transporation and biking, or thinking about pedestrian safety. Although my metrics measure where it's possible to walk to, they also don't take into account whether that walk would be pleasurable, scenic, or comfortable.</p>
        <p>But whether it's highly accurate or not, this criteria gives me an idea of areas that I can explore in Charlotte that fit my ideal lifestyle. Like many other cities, the most walkable areas of Charlotte are its urban center and the surrounding neighborhoods. I guess these are the neighborhoods I need to move to so I can walk to the library, grab some books, and then read them while sipping on a cup of coffee. </p>
    </div>
    
</div>
<div id="methods">
    <div id="content" >
        <h2>Methods</h2>
        <p>For calculating walkable areas I used atlas.co to calculate two isochrones for traveling 20 minutes on foot from each point. I dissolved the isochrones from each point into a shape: one for libraries and one for coffee shops.  The final “walkable” regions were calculated by taking the intersection of the two aforementioned isochrone shapes.</p>
        <p>For library data I used a dataset of <a href="https://data.charlottenc.gov/datasets/2624c30596134e2591056e53709eba4b/explore">Libraries from the City of Charlotte Open Data</a> portal. For coffee shops I queried Open Street Map data for “cafe” type amenities on March 13, 2024 and manually removed any coffee shops in the Airport. I removed any libraries or coffee shops that sat outside of the city limits, even if they were technically designated to Charlotte.</p>
        <p>First photo is from Unsplash and all others are Adobe Stock.</p>
    </div>
</div>


</body>

<script src="./js/config.js"></script>
<script>

var initLoad = true;
var layerTypes = {
    'fill': ['fill-opacity'],
    'line': ['line-opacity'],
    'circle': ['circle-opacity', 'circle-stroke-opacity'],
    'symbol': ['icon-opacity', 'text-opacity'],
    'raster': ['raster-opacity'],
    'fill-extrusion': ['fill-extrusion-opacity'],
    'heatmap': ['heatmap-opacity']
}

var alignments = {
    'left': 'lefty',
    'center': 'centered',
    'right': 'righty',
    'full': 'fully'
}

function getLayerPaintType(layer) {
    var layerType = map.getLayer(layer).type;
    return layerTypes[layerType];
}

function setLayerOpacity(layer) {
    var paintProps = getLayerPaintType(layer.layer);
    paintProps.forEach(function(prop) {
        var options = {};
        if (layer.duration) {
            var transitionProp = prop + "-transition";
            options = { "duration": layer.duration };
            map.setPaintProperty(layer.layer, transitionProp, options);
        }
        map.setPaintProperty(layer.layer, prop, layer.opacity, options);
    });
}

var story = document.getElementById('story');
var features = document.createElement('div');
features.setAttribute('id', 'features');

config.chapters.forEach((record, idx) => {
    var container = document.createElement('div');
    var chapter = document.createElement('div');

    if (record.title) {
        var title = document.createElement('h3');
        title.innerText = record.title;
        chapter.appendChild(title);
    }

    if (record.image) {
        var image = new Image();
        image.src = record.image;
        chapter.appendChild(image);
    }

    if (record.description) {
        var story = document.createElement('p');
        story.innerHTML = record.description;
        chapter.appendChild(story);
    }

    container.setAttribute('id', record.id);
    container.classList.add('step');
    if (idx === 0) {
        container.classList.add('active');
    }

    chapter.classList.add(config.theme);
    container.appendChild(chapter);
    container.classList.add(alignments[record.alignment] || 'centered');
    if (record.hidden) {
        container.classList.add('hidden');
    }
    features.appendChild(container);
});

story.appendChild(features);

var footer = document.createElement('div');

if (config.footer) {
    var footerText = document.createElement('p');
    footerText.innerHTML = config.footer;
    footer.appendChild(footerText);
}

if (footer.innerText.length > 0) {
    footer.classList.add(config.theme);
    footer.setAttribute('id', 'footer');
    story.appendChild(footer);
}

mapboxgl.accessToken = config.accessToken;

const transformRequest = (url) => {
    const hasQuery = url.indexOf("?") !== -1;
    const suffix = hasQuery ? "&pluginName=scrollytellingV2" : "?pluginName=scrollytellingV2";
    return {
      url: url + suffix
    }
}

var map = new mapboxgl.Map({
    container: 'map',
    style: config.style,
    center: config.chapters[0].location.center,
    zoom: config.chapters[0].location.zoom,
    bearing: config.chapters[0].location.bearing,
    pitch: config.chapters[0].location.pitch,
    interactive: false,
    transformRequest: transformRequest,
    projection: config.projection
});

map.addControl(new mapboxgl.ScaleControl());

// Create a inset map if enabled in config.js
if (config.inset) {
 var insetMap = new mapboxgl.Map({
    container: 'mapInset', // container id
    style: 'mapbox://styles/mapbox/dark-v10', //hosted style id
    center: config.chapters[0].location.center,
    // Hardcode above center value if you want insetMap to be static.
    zoom: 3, // starting zoom
    hash: false,
    interactive: false,
    attributionControl: false,
    //Future: Once official mapbox-gl-js has globe view enabled,
    //insetmap can be a globe with the following parameter.
    //projection: 'globe'
  });
}

if (config.showMarkers) {
    var marker = new mapboxgl.Marker({ color: config.markerColor });
    marker.setLngLat(config.chapters[0].location.center).addTo(map);
}

// instantiate the scrollama
var scroller = scrollama();


map.on("load", function() {
    if (config.use3dTerrain) {
        map.addSource('mapbox-dem', {
            'type': 'raster-dem',
            'url': 'mapbox://mapbox.mapbox-terrain-dem-v1',
            'tileSize': 512,
            'maxzoom': 14
        });
        // add the DEM source as a terrain layer with exaggerated height
        map.setTerrain({ 'source': 'mapbox-dem', 'exaggeration': 1.5 });

        // add a sky layer that will show when the map is highly pitched
        map.addLayer({
            'id': 'sky',
            'type': 'sky',
            'paint': {
                'sky-type': 'atmosphere',
                'sky-atmosphere-sun': [0.0, 0.0],
                'sky-atmosphere-sun-intensity': 15
            }
        });
    };

    // As the map moves, grab and update bounds in inset map.
    if (config.inset) {
    map.on('move', getInsetBounds);
    }
    // setup the instance, pass callback functions
    scroller
    .setup({
        step: '.step',
        offset: 0.5,
        progress: true
    })
    .onStepEnter(async response => {
        var current_chapter = config.chapters.findIndex(chap => chap.id === response.element.id);
        var chapter = config.chapters[current_chapter];
        
        response.element.classList.add('active');
        map[chapter.mapAnimation || 'flyTo'](chapter.location);

        // Incase you do not want to have a dynamic inset map,
        // rather want to keep it a static view but still change the
        // bbox as main map move: comment out the below if section.
        if (config.inset) {
          if (chapter.location.zoom < 5) {
            insetMap.flyTo({center: chapter.location.center, zoom: 0});
          }
          else {
            insetMap.flyTo({center: chapter.location.center, zoom: 3});
          }
        }
        if (config.showMarkers) {
            marker.setLngLat(chapter.location.center);
        }
        if (chapter.onChapterEnter.length > 0) {
            chapter.onChapterEnter.forEach(setLayerOpacity);
        }
        if (chapter.callback) {
            window[chapter.callback]();
        }
        if (chapter.rotateAnimation) {
            map.once('moveend', () => {
                const rotateNumber = map.getBearing();
                map.rotateTo(rotateNumber + 180, {
                    duration: 30000, easing: function (t) {
                        return t;
                    }
                });
            });
        }
        if (config.auto) {
             var next_chapter = (current_chapter + 1) % config.chapters.length;
             map.once('moveend', () => {
                 document.querySelectorAll('[data-scrollama-index="' + next_chapter.toString() + '"]')[0].scrollIntoView();
             });
        }
    })
    .onStepExit(response => {
        var chapter = config.chapters.find(chap => chap.id === response.element.id);
        response.element.classList.remove('active');
        if (chapter.onChapterExit.length > 0) {
            chapter.onChapterExit.forEach(setLayerOpacity);
        }
    });


    if (config.auto) {
        document.querySelectorAll('[data-scrollama-index="0"]')[0].scrollIntoView();
    }
});

//Helper functions for insetmap
function getInsetBounds() {
            let bounds = map.getBounds();

            let boundsJson = {
                "type": "FeatureCollection",
                "features": [{
                    "type": "Feature",
                    "properties": {},
                    "geometry": {
                        "type": "Polygon",
                        "coordinates": [
                            [
                                [
                                    bounds._sw.lng,
                                    bounds._sw.lat
                                ],
                                [
                                    bounds._ne.lng,
                                    bounds._sw.lat
                                ],
                                [
                                    bounds._ne.lng,
                                    bounds._ne.lat
                                ],
                                [
                                    bounds._sw.lng,
                                    bounds._ne.lat
                                ],
                                [
                                    bounds._sw.lng,
                                    bounds._sw.lat
                                ]
                            ]
                        ]
                    }
                }]
            }

            if (initLoad) {
                addInsetLayer(boundsJson);
                initLoad = false;
            } else {
                updateInsetLayer(boundsJson);
            }

        }

function addInsetLayer(bounds) {
    insetMap.addSource('boundsSource', {
        'type': 'geojson',
        'data': bounds
    });

    insetMap.addLayer({
        'id': 'boundsLayer',
        'type': 'fill',
        'source': 'boundsSource', // reference the data source
        'layout': {},
        'paint': {
            'fill-color': '#fff', // blue color fill
            'fill-opacity': 0.2
        }
    });
    // // Add a black outline around the polygon.
    insetMap.addLayer({
        'id': 'outlineLayer',
        'type': 'line',
        'source': 'boundsSource',
        'layout': {},
        'paint': {
            'line-color': '#000',
            'line-width': 1
        }
    });
}

function updateInsetLayer(bounds) {
    insetMap.getSource('boundsSource').setData(bounds);
}



// setup resize event
window.addEventListener('resize', scroller.resize);

</script>

</body>
</html>
